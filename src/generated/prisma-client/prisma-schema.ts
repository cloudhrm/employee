// Code generated by Prisma (prisma@1.29.2). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateEducation {
  count: Int!
}

type AggregateEmployee {
  count: Int!
}

type AggregateEmployeeSkill {
  count: Int!
}

type AggregateExperience {
  count: Int!
}

type AggregateKeyPair {
  count: Int!
}

type AggregateLink {
  count: Int!
}

type AggregateSkill {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Education {
  id: ID!
  employee: Employee!
  fromYear: Int!
  toYear: Int
  degree: String
  fieldOfStudy: String
  school: String
  locationText: String
  locationId: Int
  notes: String
  current: Boolean!
}

type EducationConnection {
  pageInfo: PageInfo!
  edges: [EducationEdge]!
  aggregate: AggregateEducation!
}

input EducationCreateInput {
  employee: EmployeeCreateOneWithoutEducationInput!
  fromYear: Int!
  toYear: Int
  degree: String
  fieldOfStudy: String
  school: String
  locationText: String
  locationId: Int
  notes: String
  current: Boolean!
}

input EducationCreateManyWithoutEmployeeInput {
  create: [EducationCreateWithoutEmployeeInput!]
  connect: [EducationWhereUniqueInput!]
}

input EducationCreateWithoutEmployeeInput {
  fromYear: Int!
  toYear: Int
  degree: String
  fieldOfStudy: String
  school: String
  locationText: String
  locationId: Int
  notes: String
  current: Boolean!
}

type EducationEdge {
  node: Education!
  cursor: String!
}

enum EducationOrderByInput {
  id_ASC
  id_DESC
  fromYear_ASC
  fromYear_DESC
  toYear_ASC
  toYear_DESC
  degree_ASC
  degree_DESC
  fieldOfStudy_ASC
  fieldOfStudy_DESC
  school_ASC
  school_DESC
  locationText_ASC
  locationText_DESC
  locationId_ASC
  locationId_DESC
  notes_ASC
  notes_DESC
  current_ASC
  current_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EducationPreviousValues {
  id: ID!
  fromYear: Int!
  toYear: Int
  degree: String
  fieldOfStudy: String
  school: String
  locationText: String
  locationId: Int
  notes: String
  current: Boolean!
}

input EducationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fromYear: Int
  fromYear_not: Int
  fromYear_in: [Int!]
  fromYear_not_in: [Int!]
  fromYear_lt: Int
  fromYear_lte: Int
  fromYear_gt: Int
  fromYear_gte: Int
  toYear: Int
  toYear_not: Int
  toYear_in: [Int!]
  toYear_not_in: [Int!]
  toYear_lt: Int
  toYear_lte: Int
  toYear_gt: Int
  toYear_gte: Int
  degree: String
  degree_not: String
  degree_in: [String!]
  degree_not_in: [String!]
  degree_lt: String
  degree_lte: String
  degree_gt: String
  degree_gte: String
  degree_contains: String
  degree_not_contains: String
  degree_starts_with: String
  degree_not_starts_with: String
  degree_ends_with: String
  degree_not_ends_with: String
  fieldOfStudy: String
  fieldOfStudy_not: String
  fieldOfStudy_in: [String!]
  fieldOfStudy_not_in: [String!]
  fieldOfStudy_lt: String
  fieldOfStudy_lte: String
  fieldOfStudy_gt: String
  fieldOfStudy_gte: String
  fieldOfStudy_contains: String
  fieldOfStudy_not_contains: String
  fieldOfStudy_starts_with: String
  fieldOfStudy_not_starts_with: String
  fieldOfStudy_ends_with: String
  fieldOfStudy_not_ends_with: String
  school: String
  school_not: String
  school_in: [String!]
  school_not_in: [String!]
  school_lt: String
  school_lte: String
  school_gt: String
  school_gte: String
  school_contains: String
  school_not_contains: String
  school_starts_with: String
  school_not_starts_with: String
  school_ends_with: String
  school_not_ends_with: String
  locationText: String
  locationText_not: String
  locationText_in: [String!]
  locationText_not_in: [String!]
  locationText_lt: String
  locationText_lte: String
  locationText_gt: String
  locationText_gte: String
  locationText_contains: String
  locationText_not_contains: String
  locationText_starts_with: String
  locationText_not_starts_with: String
  locationText_ends_with: String
  locationText_not_ends_with: String
  locationId: Int
  locationId_not: Int
  locationId_in: [Int!]
  locationId_not_in: [Int!]
  locationId_lt: Int
  locationId_lte: Int
  locationId_gt: Int
  locationId_gte: Int
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  current: Boolean
  current_not: Boolean
  AND: [EducationScalarWhereInput!]
  OR: [EducationScalarWhereInput!]
  NOT: [EducationScalarWhereInput!]
}

type EducationSubscriptionPayload {
  mutation: MutationType!
  node: Education
  updatedFields: [String!]
  previousValues: EducationPreviousValues
}

input EducationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EducationWhereInput
  AND: [EducationSubscriptionWhereInput!]
  OR: [EducationSubscriptionWhereInput!]
  NOT: [EducationSubscriptionWhereInput!]
}

input EducationUpdateInput {
  employee: EmployeeUpdateOneRequiredWithoutEducationInput
  fromYear: Int
  toYear: Int
  degree: String
  fieldOfStudy: String
  school: String
  locationText: String
  locationId: Int
  notes: String
  current: Boolean
}

input EducationUpdateManyDataInput {
  fromYear: Int
  toYear: Int
  degree: String
  fieldOfStudy: String
  school: String
  locationText: String
  locationId: Int
  notes: String
  current: Boolean
}

input EducationUpdateManyMutationInput {
  fromYear: Int
  toYear: Int
  degree: String
  fieldOfStudy: String
  school: String
  locationText: String
  locationId: Int
  notes: String
  current: Boolean
}

input EducationUpdateManyWithoutEmployeeInput {
  create: [EducationCreateWithoutEmployeeInput!]
  delete: [EducationWhereUniqueInput!]
  connect: [EducationWhereUniqueInput!]
  set: [EducationWhereUniqueInput!]
  disconnect: [EducationWhereUniqueInput!]
  update: [EducationUpdateWithWhereUniqueWithoutEmployeeInput!]
  upsert: [EducationUpsertWithWhereUniqueWithoutEmployeeInput!]
  deleteMany: [EducationScalarWhereInput!]
  updateMany: [EducationUpdateManyWithWhereNestedInput!]
}

input EducationUpdateManyWithWhereNestedInput {
  where: EducationScalarWhereInput!
  data: EducationUpdateManyDataInput!
}

input EducationUpdateWithoutEmployeeDataInput {
  fromYear: Int
  toYear: Int
  degree: String
  fieldOfStudy: String
  school: String
  locationText: String
  locationId: Int
  notes: String
  current: Boolean
}

input EducationUpdateWithWhereUniqueWithoutEmployeeInput {
  where: EducationWhereUniqueInput!
  data: EducationUpdateWithoutEmployeeDataInput!
}

input EducationUpsertWithWhereUniqueWithoutEmployeeInput {
  where: EducationWhereUniqueInput!
  update: EducationUpdateWithoutEmployeeDataInput!
  create: EducationCreateWithoutEmployeeInput!
}

input EducationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  employee: EmployeeWhereInput
  fromYear: Int
  fromYear_not: Int
  fromYear_in: [Int!]
  fromYear_not_in: [Int!]
  fromYear_lt: Int
  fromYear_lte: Int
  fromYear_gt: Int
  fromYear_gte: Int
  toYear: Int
  toYear_not: Int
  toYear_in: [Int!]
  toYear_not_in: [Int!]
  toYear_lt: Int
  toYear_lte: Int
  toYear_gt: Int
  toYear_gte: Int
  degree: String
  degree_not: String
  degree_in: [String!]
  degree_not_in: [String!]
  degree_lt: String
  degree_lte: String
  degree_gt: String
  degree_gte: String
  degree_contains: String
  degree_not_contains: String
  degree_starts_with: String
  degree_not_starts_with: String
  degree_ends_with: String
  degree_not_ends_with: String
  fieldOfStudy: String
  fieldOfStudy_not: String
  fieldOfStudy_in: [String!]
  fieldOfStudy_not_in: [String!]
  fieldOfStudy_lt: String
  fieldOfStudy_lte: String
  fieldOfStudy_gt: String
  fieldOfStudy_gte: String
  fieldOfStudy_contains: String
  fieldOfStudy_not_contains: String
  fieldOfStudy_starts_with: String
  fieldOfStudy_not_starts_with: String
  fieldOfStudy_ends_with: String
  fieldOfStudy_not_ends_with: String
  school: String
  school_not: String
  school_in: [String!]
  school_not_in: [String!]
  school_lt: String
  school_lte: String
  school_gt: String
  school_gte: String
  school_contains: String
  school_not_contains: String
  school_starts_with: String
  school_not_starts_with: String
  school_ends_with: String
  school_not_ends_with: String
  locationText: String
  locationText_not: String
  locationText_in: [String!]
  locationText_not_in: [String!]
  locationText_lt: String
  locationText_lte: String
  locationText_gt: String
  locationText_gte: String
  locationText_contains: String
  locationText_not_contains: String
  locationText_starts_with: String
  locationText_not_starts_with: String
  locationText_ends_with: String
  locationText_not_ends_with: String
  locationId: Int
  locationId_not: Int
  locationId_in: [Int!]
  locationId_not_in: [Int!]
  locationId_lt: Int
  locationId_lte: Int
  locationId_gt: Int
  locationId_gte: Int
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  current: Boolean
  current_not: Boolean
  AND: [EducationWhereInput!]
  OR: [EducationWhereInput!]
  NOT: [EducationWhereInput!]
}

input EducationWhereUniqueInput {
  id: ID
}

type Employee {
  id: ID!
  userId: String!
  companyId: String
  firstName: String!
  lastName: String!
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
  skills(where: EmployeeSkillWhereInput, orderBy: EmployeeSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [EmployeeSkill!]
  links(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Link!]
  experience(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience!]
  education(where: EducationWhereInput, orderBy: EducationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Education!]
}

type EmployeeConnection {
  pageInfo: PageInfo!
  edges: [EmployeeEdge]!
  aggregate: AggregateEmployee!
}

input EmployeeCreateInput {
  userId: String!
  companyId: String
  firstName: String!
  lastName: String!
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
  skills: EmployeeSkillCreateManyWithoutEmployeeInput
  links: LinkCreateManyWithoutEmployeeInput
  experience: ExperienceCreateManyInput
  education: EducationCreateManyWithoutEmployeeInput
}

input EmployeeCreateOneWithoutEducationInput {
  create: EmployeeCreateWithoutEducationInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateOneWithoutLinksInput {
  create: EmployeeCreateWithoutLinksInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateOneWithoutSkillsInput {
  create: EmployeeCreateWithoutSkillsInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateWithoutEducationInput {
  userId: String!
  companyId: String
  firstName: String!
  lastName: String!
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
  skills: EmployeeSkillCreateManyWithoutEmployeeInput
  links: LinkCreateManyWithoutEmployeeInput
  experience: ExperienceCreateManyInput
}

input EmployeeCreateWithoutLinksInput {
  userId: String!
  companyId: String
  firstName: String!
  lastName: String!
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
  skills: EmployeeSkillCreateManyWithoutEmployeeInput
  experience: ExperienceCreateManyInput
  education: EducationCreateManyWithoutEmployeeInput
}

input EmployeeCreateWithoutSkillsInput {
  userId: String!
  companyId: String
  firstName: String!
  lastName: String!
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
  links: LinkCreateManyWithoutEmployeeInput
  experience: ExperienceCreateManyInput
  education: EducationCreateManyWithoutEmployeeInput
}

type EmployeeEdge {
  node: Employee!
  cursor: String!
}

enum EmployeeOrderByInput {
  id_ASC
  id_DESC
  userId_ASC
  userId_DESC
  companyId_ASC
  companyId_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  livingLocationText_ASC
  livingLocationText_DESC
  livingplaceId_ASC
  livingplaceId_DESC
  about_ASC
  about_DESC
  workSince_ASC
  workSince_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EmployeePreviousValues {
  id: ID!
  userId: String!
  companyId: String
  firstName: String!
  lastName: String!
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
}

type EmployeeSkill {
  id: ID!
  employee: Employee!
  skill: Skill!
  years: Int
}

type EmployeeSkillConnection {
  pageInfo: PageInfo!
  edges: [EmployeeSkillEdge]!
  aggregate: AggregateEmployeeSkill!
}

input EmployeeSkillCreateInput {
  employee: EmployeeCreateOneWithoutSkillsInput!
  skill: SkillCreateOneInput!
  years: Int
}

input EmployeeSkillCreateManyWithoutEmployeeInput {
  create: [EmployeeSkillCreateWithoutEmployeeInput!]
  connect: [EmployeeSkillWhereUniqueInput!]
}

input EmployeeSkillCreateWithoutEmployeeInput {
  skill: SkillCreateOneInput!
  years: Int
}

type EmployeeSkillEdge {
  node: EmployeeSkill!
  cursor: String!
}

enum EmployeeSkillOrderByInput {
  id_ASC
  id_DESC
  years_ASC
  years_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EmployeeSkillPreviousValues {
  id: ID!
  years: Int
}

input EmployeeSkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  years: Int
  years_not: Int
  years_in: [Int!]
  years_not_in: [Int!]
  years_lt: Int
  years_lte: Int
  years_gt: Int
  years_gte: Int
  AND: [EmployeeSkillScalarWhereInput!]
  OR: [EmployeeSkillScalarWhereInput!]
  NOT: [EmployeeSkillScalarWhereInput!]
}

type EmployeeSkillSubscriptionPayload {
  mutation: MutationType!
  node: EmployeeSkill
  updatedFields: [String!]
  previousValues: EmployeeSkillPreviousValues
}

input EmployeeSkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployeeSkillWhereInput
  AND: [EmployeeSkillSubscriptionWhereInput!]
  OR: [EmployeeSkillSubscriptionWhereInput!]
  NOT: [EmployeeSkillSubscriptionWhereInput!]
}

input EmployeeSkillUpdateInput {
  employee: EmployeeUpdateOneRequiredWithoutSkillsInput
  skill: SkillUpdateOneRequiredInput
  years: Int
}

input EmployeeSkillUpdateManyDataInput {
  years: Int
}

input EmployeeSkillUpdateManyMutationInput {
  years: Int
}

input EmployeeSkillUpdateManyWithoutEmployeeInput {
  create: [EmployeeSkillCreateWithoutEmployeeInput!]
  delete: [EmployeeSkillWhereUniqueInput!]
  connect: [EmployeeSkillWhereUniqueInput!]
  set: [EmployeeSkillWhereUniqueInput!]
  disconnect: [EmployeeSkillWhereUniqueInput!]
  update: [EmployeeSkillUpdateWithWhereUniqueWithoutEmployeeInput!]
  upsert: [EmployeeSkillUpsertWithWhereUniqueWithoutEmployeeInput!]
  deleteMany: [EmployeeSkillScalarWhereInput!]
  updateMany: [EmployeeSkillUpdateManyWithWhereNestedInput!]
}

input EmployeeSkillUpdateManyWithWhereNestedInput {
  where: EmployeeSkillScalarWhereInput!
  data: EmployeeSkillUpdateManyDataInput!
}

input EmployeeSkillUpdateWithoutEmployeeDataInput {
  skill: SkillUpdateOneRequiredInput
  years: Int
}

input EmployeeSkillUpdateWithWhereUniqueWithoutEmployeeInput {
  where: EmployeeSkillWhereUniqueInput!
  data: EmployeeSkillUpdateWithoutEmployeeDataInput!
}

input EmployeeSkillUpsertWithWhereUniqueWithoutEmployeeInput {
  where: EmployeeSkillWhereUniqueInput!
  update: EmployeeSkillUpdateWithoutEmployeeDataInput!
  create: EmployeeSkillCreateWithoutEmployeeInput!
}

input EmployeeSkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  employee: EmployeeWhereInput
  skill: SkillWhereInput
  years: Int
  years_not: Int
  years_in: [Int!]
  years_not_in: [Int!]
  years_lt: Int
  years_lte: Int
  years_gt: Int
  years_gte: Int
  AND: [EmployeeSkillWhereInput!]
  OR: [EmployeeSkillWhereInput!]
  NOT: [EmployeeSkillWhereInput!]
}

input EmployeeSkillWhereUniqueInput {
  id: ID
}

type EmployeeSubscriptionPayload {
  mutation: MutationType!
  node: Employee
  updatedFields: [String!]
  previousValues: EmployeePreviousValues
}

input EmployeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployeeWhereInput
  AND: [EmployeeSubscriptionWhereInput!]
  OR: [EmployeeSubscriptionWhereInput!]
  NOT: [EmployeeSubscriptionWhereInput!]
}

input EmployeeUpdateInput {
  userId: String
  companyId: String
  firstName: String
  lastName: String
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
  skills: EmployeeSkillUpdateManyWithoutEmployeeInput
  links: LinkUpdateManyWithoutEmployeeInput
  experience: ExperienceUpdateManyInput
  education: EducationUpdateManyWithoutEmployeeInput
}

input EmployeeUpdateManyMutationInput {
  userId: String
  companyId: String
  firstName: String
  lastName: String
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
}

input EmployeeUpdateOneRequiredWithoutEducationInput {
  create: EmployeeCreateWithoutEducationInput
  update: EmployeeUpdateWithoutEducationDataInput
  upsert: EmployeeUpsertWithoutEducationInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpdateOneRequiredWithoutLinksInput {
  create: EmployeeCreateWithoutLinksInput
  update: EmployeeUpdateWithoutLinksDataInput
  upsert: EmployeeUpsertWithoutLinksInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpdateOneRequiredWithoutSkillsInput {
  create: EmployeeCreateWithoutSkillsInput
  update: EmployeeUpdateWithoutSkillsDataInput
  upsert: EmployeeUpsertWithoutSkillsInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpdateWithoutEducationDataInput {
  userId: String
  companyId: String
  firstName: String
  lastName: String
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
  skills: EmployeeSkillUpdateManyWithoutEmployeeInput
  links: LinkUpdateManyWithoutEmployeeInput
  experience: ExperienceUpdateManyInput
}

input EmployeeUpdateWithoutLinksDataInput {
  userId: String
  companyId: String
  firstName: String
  lastName: String
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
  skills: EmployeeSkillUpdateManyWithoutEmployeeInput
  experience: ExperienceUpdateManyInput
  education: EducationUpdateManyWithoutEmployeeInput
}

input EmployeeUpdateWithoutSkillsDataInput {
  userId: String
  companyId: String
  firstName: String
  lastName: String
  livingLocationText: String
  livingplaceId: Int
  about: String
  workSince: Int
  links: LinkUpdateManyWithoutEmployeeInput
  experience: ExperienceUpdateManyInput
  education: EducationUpdateManyWithoutEmployeeInput
}

input EmployeeUpsertWithoutEducationInput {
  update: EmployeeUpdateWithoutEducationDataInput!
  create: EmployeeCreateWithoutEducationInput!
}

input EmployeeUpsertWithoutLinksInput {
  update: EmployeeUpdateWithoutLinksDataInput!
  create: EmployeeCreateWithoutLinksInput!
}

input EmployeeUpsertWithoutSkillsInput {
  update: EmployeeUpdateWithoutSkillsDataInput!
  create: EmployeeCreateWithoutSkillsInput!
}

input EmployeeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userId: String
  userId_not: String
  userId_in: [String!]
  userId_not_in: [String!]
  userId_lt: String
  userId_lte: String
  userId_gt: String
  userId_gte: String
  userId_contains: String
  userId_not_contains: String
  userId_starts_with: String
  userId_not_starts_with: String
  userId_ends_with: String
  userId_not_ends_with: String
  companyId: String
  companyId_not: String
  companyId_in: [String!]
  companyId_not_in: [String!]
  companyId_lt: String
  companyId_lte: String
  companyId_gt: String
  companyId_gte: String
  companyId_contains: String
  companyId_not_contains: String
  companyId_starts_with: String
  companyId_not_starts_with: String
  companyId_ends_with: String
  companyId_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  livingLocationText: String
  livingLocationText_not: String
  livingLocationText_in: [String!]
  livingLocationText_not_in: [String!]
  livingLocationText_lt: String
  livingLocationText_lte: String
  livingLocationText_gt: String
  livingLocationText_gte: String
  livingLocationText_contains: String
  livingLocationText_not_contains: String
  livingLocationText_starts_with: String
  livingLocationText_not_starts_with: String
  livingLocationText_ends_with: String
  livingLocationText_not_ends_with: String
  livingplaceId: Int
  livingplaceId_not: Int
  livingplaceId_in: [Int!]
  livingplaceId_not_in: [Int!]
  livingplaceId_lt: Int
  livingplaceId_lte: Int
  livingplaceId_gt: Int
  livingplaceId_gte: Int
  about: String
  about_not: String
  about_in: [String!]
  about_not_in: [String!]
  about_lt: String
  about_lte: String
  about_gt: String
  about_gte: String
  about_contains: String
  about_not_contains: String
  about_starts_with: String
  about_not_starts_with: String
  about_ends_with: String
  about_not_ends_with: String
  workSince: Int
  workSince_not: Int
  workSince_in: [Int!]
  workSince_not_in: [Int!]
  workSince_lt: Int
  workSince_lte: Int
  workSince_gt: Int
  workSince_gte: Int
  skills_every: EmployeeSkillWhereInput
  skills_some: EmployeeSkillWhereInput
  skills_none: EmployeeSkillWhereInput
  links_every: LinkWhereInput
  links_some: LinkWhereInput
  links_none: LinkWhereInput
  experience_every: ExperienceWhereInput
  experience_some: ExperienceWhereInput
  experience_none: ExperienceWhereInput
  education_every: EducationWhereInput
  education_some: EducationWhereInput
  education_none: EducationWhereInput
  AND: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
}

input EmployeeWhereUniqueInput {
  id: ID
  userId: String
}

type Experience {
  id: ID!
  position: String!
  company: String!
  companyId: String
  locationText: String
  locationid: Int
  fromYear: Int
  toYear: Int
  current: Boolean!
}

type ExperienceConnection {
  pageInfo: PageInfo!
  edges: [ExperienceEdge]!
  aggregate: AggregateExperience!
}

input ExperienceCreateInput {
  position: String!
  company: String!
  companyId: String
  locationText: String
  locationid: Int
  fromYear: Int
  toYear: Int
  current: Boolean!
}

input ExperienceCreateManyInput {
  create: [ExperienceCreateInput!]
  connect: [ExperienceWhereUniqueInput!]
}

type ExperienceEdge {
  node: Experience!
  cursor: String!
}

enum ExperienceOrderByInput {
  id_ASC
  id_DESC
  position_ASC
  position_DESC
  company_ASC
  company_DESC
  companyId_ASC
  companyId_DESC
  locationText_ASC
  locationText_DESC
  locationid_ASC
  locationid_DESC
  fromYear_ASC
  fromYear_DESC
  toYear_ASC
  toYear_DESC
  current_ASC
  current_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExperiencePreviousValues {
  id: ID!
  position: String!
  company: String!
  companyId: String
  locationText: String
  locationid: Int
  fromYear: Int
  toYear: Int
  current: Boolean!
}

input ExperienceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  position: String
  position_not: String
  position_in: [String!]
  position_not_in: [String!]
  position_lt: String
  position_lte: String
  position_gt: String
  position_gte: String
  position_contains: String
  position_not_contains: String
  position_starts_with: String
  position_not_starts_with: String
  position_ends_with: String
  position_not_ends_with: String
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  companyId: String
  companyId_not: String
  companyId_in: [String!]
  companyId_not_in: [String!]
  companyId_lt: String
  companyId_lte: String
  companyId_gt: String
  companyId_gte: String
  companyId_contains: String
  companyId_not_contains: String
  companyId_starts_with: String
  companyId_not_starts_with: String
  companyId_ends_with: String
  companyId_not_ends_with: String
  locationText: String
  locationText_not: String
  locationText_in: [String!]
  locationText_not_in: [String!]
  locationText_lt: String
  locationText_lte: String
  locationText_gt: String
  locationText_gte: String
  locationText_contains: String
  locationText_not_contains: String
  locationText_starts_with: String
  locationText_not_starts_with: String
  locationText_ends_with: String
  locationText_not_ends_with: String
  locationid: Int
  locationid_not: Int
  locationid_in: [Int!]
  locationid_not_in: [Int!]
  locationid_lt: Int
  locationid_lte: Int
  locationid_gt: Int
  locationid_gte: Int
  fromYear: Int
  fromYear_not: Int
  fromYear_in: [Int!]
  fromYear_not_in: [Int!]
  fromYear_lt: Int
  fromYear_lte: Int
  fromYear_gt: Int
  fromYear_gte: Int
  toYear: Int
  toYear_not: Int
  toYear_in: [Int!]
  toYear_not_in: [Int!]
  toYear_lt: Int
  toYear_lte: Int
  toYear_gt: Int
  toYear_gte: Int
  current: Boolean
  current_not: Boolean
  AND: [ExperienceScalarWhereInput!]
  OR: [ExperienceScalarWhereInput!]
  NOT: [ExperienceScalarWhereInput!]
}

type ExperienceSubscriptionPayload {
  mutation: MutationType!
  node: Experience
  updatedFields: [String!]
  previousValues: ExperiencePreviousValues
}

input ExperienceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExperienceWhereInput
  AND: [ExperienceSubscriptionWhereInput!]
  OR: [ExperienceSubscriptionWhereInput!]
  NOT: [ExperienceSubscriptionWhereInput!]
}

input ExperienceUpdateDataInput {
  position: String
  company: String
  companyId: String
  locationText: String
  locationid: Int
  fromYear: Int
  toYear: Int
  current: Boolean
}

input ExperienceUpdateInput {
  position: String
  company: String
  companyId: String
  locationText: String
  locationid: Int
  fromYear: Int
  toYear: Int
  current: Boolean
}

input ExperienceUpdateManyDataInput {
  position: String
  company: String
  companyId: String
  locationText: String
  locationid: Int
  fromYear: Int
  toYear: Int
  current: Boolean
}

input ExperienceUpdateManyInput {
  create: [ExperienceCreateInput!]
  update: [ExperienceUpdateWithWhereUniqueNestedInput!]
  upsert: [ExperienceUpsertWithWhereUniqueNestedInput!]
  delete: [ExperienceWhereUniqueInput!]
  connect: [ExperienceWhereUniqueInput!]
  set: [ExperienceWhereUniqueInput!]
  disconnect: [ExperienceWhereUniqueInput!]
  deleteMany: [ExperienceScalarWhereInput!]
  updateMany: [ExperienceUpdateManyWithWhereNestedInput!]
}

input ExperienceUpdateManyMutationInput {
  position: String
  company: String
  companyId: String
  locationText: String
  locationid: Int
  fromYear: Int
  toYear: Int
  current: Boolean
}

input ExperienceUpdateManyWithWhereNestedInput {
  where: ExperienceScalarWhereInput!
  data: ExperienceUpdateManyDataInput!
}

input ExperienceUpdateWithWhereUniqueNestedInput {
  where: ExperienceWhereUniqueInput!
  data: ExperienceUpdateDataInput!
}

input ExperienceUpsertWithWhereUniqueNestedInput {
  where: ExperienceWhereUniqueInput!
  update: ExperienceUpdateDataInput!
  create: ExperienceCreateInput!
}

input ExperienceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  position: String
  position_not: String
  position_in: [String!]
  position_not_in: [String!]
  position_lt: String
  position_lte: String
  position_gt: String
  position_gte: String
  position_contains: String
  position_not_contains: String
  position_starts_with: String
  position_not_starts_with: String
  position_ends_with: String
  position_not_ends_with: String
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  companyId: String
  companyId_not: String
  companyId_in: [String!]
  companyId_not_in: [String!]
  companyId_lt: String
  companyId_lte: String
  companyId_gt: String
  companyId_gte: String
  companyId_contains: String
  companyId_not_contains: String
  companyId_starts_with: String
  companyId_not_starts_with: String
  companyId_ends_with: String
  companyId_not_ends_with: String
  locationText: String
  locationText_not: String
  locationText_in: [String!]
  locationText_not_in: [String!]
  locationText_lt: String
  locationText_lte: String
  locationText_gt: String
  locationText_gte: String
  locationText_contains: String
  locationText_not_contains: String
  locationText_starts_with: String
  locationText_not_starts_with: String
  locationText_ends_with: String
  locationText_not_ends_with: String
  locationid: Int
  locationid_not: Int
  locationid_in: [Int!]
  locationid_not_in: [Int!]
  locationid_lt: Int
  locationid_lte: Int
  locationid_gt: Int
  locationid_gte: Int
  fromYear: Int
  fromYear_not: Int
  fromYear_in: [Int!]
  fromYear_not_in: [Int!]
  fromYear_lt: Int
  fromYear_lte: Int
  fromYear_gt: Int
  fromYear_gte: Int
  toYear: Int
  toYear_not: Int
  toYear_in: [Int!]
  toYear_not_in: [Int!]
  toYear_lt: Int
  toYear_lte: Int
  toYear_gt: Int
  toYear_gte: Int
  current: Boolean
  current_not: Boolean
  AND: [ExperienceWhereInput!]
  OR: [ExperienceWhereInput!]
  NOT: [ExperienceWhereInput!]
}

input ExperienceWhereUniqueInput {
  id: ID
}

type KeyPair {
  keyId: String!
  public: String!
}

type KeyPairConnection {
  pageInfo: PageInfo!
  edges: [KeyPairEdge]!
  aggregate: AggregateKeyPair!
}

input KeyPairCreateInput {
  keyId: String!
  public: String!
}

type KeyPairEdge {
  node: KeyPair!
  cursor: String!
}

enum KeyPairOrderByInput {
  keyId_ASC
  keyId_DESC
  public_ASC
  public_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type KeyPairPreviousValues {
  keyId: String!
  public: String!
}

type KeyPairSubscriptionPayload {
  mutation: MutationType!
  node: KeyPair
  updatedFields: [String!]
  previousValues: KeyPairPreviousValues
}

input KeyPairSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: KeyPairWhereInput
  AND: [KeyPairSubscriptionWhereInput!]
  OR: [KeyPairSubscriptionWhereInput!]
  NOT: [KeyPairSubscriptionWhereInput!]
}

input KeyPairUpdateInput {
  keyId: String
  public: String
}

input KeyPairUpdateManyMutationInput {
  keyId: String
  public: String
}

input KeyPairWhereInput {
  keyId: String
  keyId_not: String
  keyId_in: [String!]
  keyId_not_in: [String!]
  keyId_lt: String
  keyId_lte: String
  keyId_gt: String
  keyId_gte: String
  keyId_contains: String
  keyId_not_contains: String
  keyId_starts_with: String
  keyId_not_starts_with: String
  keyId_ends_with: String
  keyId_not_ends_with: String
  public: String
  public_not: String
  public_in: [String!]
  public_not_in: [String!]
  public_lt: String
  public_lte: String
  public_gt: String
  public_gte: String
  public_contains: String
  public_not_contains: String
  public_starts_with: String
  public_not_starts_with: String
  public_ends_with: String
  public_not_ends_with: String
  AND: [KeyPairWhereInput!]
  OR: [KeyPairWhereInput!]
  NOT: [KeyPairWhereInput!]
}

input KeyPairWhereUniqueInput {
  keyId: String
}

type Link {
  id: ID!
  employee: Employee!
  link: String!
}

type LinkConnection {
  pageInfo: PageInfo!
  edges: [LinkEdge]!
  aggregate: AggregateLink!
}

input LinkCreateInput {
  employee: EmployeeCreateOneWithoutLinksInput!
  link: String!
}

input LinkCreateManyWithoutEmployeeInput {
  create: [LinkCreateWithoutEmployeeInput!]
  connect: [LinkWhereUniqueInput!]
}

input LinkCreateWithoutEmployeeInput {
  link: String!
}

type LinkEdge {
  node: Link!
  cursor: String!
}

enum LinkOrderByInput {
  id_ASC
  id_DESC
  link_ASC
  link_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LinkPreviousValues {
  id: ID!
  link: String!
}

input LinkScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  AND: [LinkScalarWhereInput!]
  OR: [LinkScalarWhereInput!]
  NOT: [LinkScalarWhereInput!]
}

type LinkSubscriptionPayload {
  mutation: MutationType!
  node: Link
  updatedFields: [String!]
  previousValues: LinkPreviousValues
}

input LinkSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LinkWhereInput
  AND: [LinkSubscriptionWhereInput!]
  OR: [LinkSubscriptionWhereInput!]
  NOT: [LinkSubscriptionWhereInput!]
}

input LinkUpdateInput {
  employee: EmployeeUpdateOneRequiredWithoutLinksInput
  link: String
}

input LinkUpdateManyDataInput {
  link: String
}

input LinkUpdateManyMutationInput {
  link: String
}

input LinkUpdateManyWithoutEmployeeInput {
  create: [LinkCreateWithoutEmployeeInput!]
  delete: [LinkWhereUniqueInput!]
  connect: [LinkWhereUniqueInput!]
  set: [LinkWhereUniqueInput!]
  disconnect: [LinkWhereUniqueInput!]
  update: [LinkUpdateWithWhereUniqueWithoutEmployeeInput!]
  upsert: [LinkUpsertWithWhereUniqueWithoutEmployeeInput!]
  deleteMany: [LinkScalarWhereInput!]
  updateMany: [LinkUpdateManyWithWhereNestedInput!]
}

input LinkUpdateManyWithWhereNestedInput {
  where: LinkScalarWhereInput!
  data: LinkUpdateManyDataInput!
}

input LinkUpdateWithoutEmployeeDataInput {
  link: String
}

input LinkUpdateWithWhereUniqueWithoutEmployeeInput {
  where: LinkWhereUniqueInput!
  data: LinkUpdateWithoutEmployeeDataInput!
}

input LinkUpsertWithWhereUniqueWithoutEmployeeInput {
  where: LinkWhereUniqueInput!
  update: LinkUpdateWithoutEmployeeDataInput!
  create: LinkCreateWithoutEmployeeInput!
}

input LinkWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  employee: EmployeeWhereInput
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  AND: [LinkWhereInput!]
  OR: [LinkWhereInput!]
  NOT: [LinkWhereInput!]
}

input LinkWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createEducation(data: EducationCreateInput!): Education!
  updateEducation(data: EducationUpdateInput!, where: EducationWhereUniqueInput!): Education
  updateManyEducations(data: EducationUpdateManyMutationInput!, where: EducationWhereInput): BatchPayload!
  upsertEducation(where: EducationWhereUniqueInput!, create: EducationCreateInput!, update: EducationUpdateInput!): Education!
  deleteEducation(where: EducationWhereUniqueInput!): Education
  deleteManyEducations(where: EducationWhereInput): BatchPayload!
  createEmployee(data: EmployeeCreateInput!): Employee!
  updateEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateManyEmployees(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): BatchPayload!
  upsertEmployee(where: EmployeeWhereUniqueInput!, create: EmployeeCreateInput!, update: EmployeeUpdateInput!): Employee!
  deleteEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteManyEmployees(where: EmployeeWhereInput): BatchPayload!
  createEmployeeSkill(data: EmployeeSkillCreateInput!): EmployeeSkill!
  updateEmployeeSkill(data: EmployeeSkillUpdateInput!, where: EmployeeSkillWhereUniqueInput!): EmployeeSkill
  updateManyEmployeeSkills(data: EmployeeSkillUpdateManyMutationInput!, where: EmployeeSkillWhereInput): BatchPayload!
  upsertEmployeeSkill(where: EmployeeSkillWhereUniqueInput!, create: EmployeeSkillCreateInput!, update: EmployeeSkillUpdateInput!): EmployeeSkill!
  deleteEmployeeSkill(where: EmployeeSkillWhereUniqueInput!): EmployeeSkill
  deleteManyEmployeeSkills(where: EmployeeSkillWhereInput): BatchPayload!
  createExperience(data: ExperienceCreateInput!): Experience!
  updateExperience(data: ExperienceUpdateInput!, where: ExperienceWhereUniqueInput!): Experience
  updateManyExperiences(data: ExperienceUpdateManyMutationInput!, where: ExperienceWhereInput): BatchPayload!
  upsertExperience(where: ExperienceWhereUniqueInput!, create: ExperienceCreateInput!, update: ExperienceUpdateInput!): Experience!
  deleteExperience(where: ExperienceWhereUniqueInput!): Experience
  deleteManyExperiences(where: ExperienceWhereInput): BatchPayload!
  createKeyPair(data: KeyPairCreateInput!): KeyPair!
  updateKeyPair(data: KeyPairUpdateInput!, where: KeyPairWhereUniqueInput!): KeyPair
  updateManyKeyPairs(data: KeyPairUpdateManyMutationInput!, where: KeyPairWhereInput): BatchPayload!
  upsertKeyPair(where: KeyPairWhereUniqueInput!, create: KeyPairCreateInput!, update: KeyPairUpdateInput!): KeyPair!
  deleteKeyPair(where: KeyPairWhereUniqueInput!): KeyPair
  deleteManyKeyPairs(where: KeyPairWhereInput): BatchPayload!
  createLink(data: LinkCreateInput!): Link!
  updateLink(data: LinkUpdateInput!, where: LinkWhereUniqueInput!): Link
  updateManyLinks(data: LinkUpdateManyMutationInput!, where: LinkWhereInput): BatchPayload!
  upsertLink(where: LinkWhereUniqueInput!, create: LinkCreateInput!, update: LinkUpdateInput!): Link!
  deleteLink(where: LinkWhereUniqueInput!): Link
  deleteManyLinks(where: LinkWhereInput): BatchPayload!
  createSkill(data: SkillCreateInput!): Skill!
  updateSkill(data: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill
  updateManySkills(data: SkillUpdateManyMutationInput!, where: SkillWhereInput): BatchPayload!
  upsertSkill(where: SkillWhereUniqueInput!, create: SkillCreateInput!, update: SkillUpdateInput!): Skill!
  deleteSkill(where: SkillWhereUniqueInput!): Skill
  deleteManySkills(where: SkillWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  education(where: EducationWhereUniqueInput!): Education
  educations(where: EducationWhereInput, orderBy: EducationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Education]!
  educationsConnection(where: EducationWhereInput, orderBy: EducationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EducationConnection!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Employee]!
  employeesConnection(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployeeConnection!
  employeeSkill(where: EmployeeSkillWhereUniqueInput!): EmployeeSkill
  employeeSkills(where: EmployeeSkillWhereInput, orderBy: EmployeeSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [EmployeeSkill]!
  employeeSkillsConnection(where: EmployeeSkillWhereInput, orderBy: EmployeeSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployeeSkillConnection!
  experience(where: ExperienceWhereUniqueInput!): Experience
  experiences(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience]!
  experiencesConnection(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExperienceConnection!
  keyPair(where: KeyPairWhereUniqueInput!): KeyPair
  keyPairs(where: KeyPairWhereInput, orderBy: KeyPairOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [KeyPair]!
  keyPairsConnection(where: KeyPairWhereInput, orderBy: KeyPairOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): KeyPairConnection!
  link(where: LinkWhereUniqueInput!): Link
  links(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Link]!
  linksConnection(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LinkConnection!
  skill(where: SkillWhereUniqueInput!): Skill
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill]!
  skillsConnection(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SkillConnection!
  node(id: ID!): Node
}

type Skill {
  id: ID!
  name: String!
}

type SkillConnection {
  pageInfo: PageInfo!
  edges: [SkillEdge]!
  aggregate: AggregateSkill!
}

input SkillCreateInput {
  name: String!
}

input SkillCreateOneInput {
  create: SkillCreateInput
  connect: SkillWhereUniqueInput
}

type SkillEdge {
  node: Skill!
  cursor: String!
}

enum SkillOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SkillPreviousValues {
  id: ID!
  name: String!
}

type SkillSubscriptionPayload {
  mutation: MutationType!
  node: Skill
  updatedFields: [String!]
  previousValues: SkillPreviousValues
}

input SkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SkillWhereInput
  AND: [SkillSubscriptionWhereInput!]
  OR: [SkillSubscriptionWhereInput!]
  NOT: [SkillSubscriptionWhereInput!]
}

input SkillUpdateDataInput {
  name: String
}

input SkillUpdateInput {
  name: String
}

input SkillUpdateManyMutationInput {
  name: String
}

input SkillUpdateOneRequiredInput {
  create: SkillCreateInput
  update: SkillUpdateDataInput
  upsert: SkillUpsertNestedInput
  connect: SkillWhereUniqueInput
}

input SkillUpsertNestedInput {
  update: SkillUpdateDataInput!
  create: SkillCreateInput!
}

input SkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SkillWhereInput!]
  OR: [SkillWhereInput!]
  NOT: [SkillWhereInput!]
}

input SkillWhereUniqueInput {
  id: ID
}

type Subscription {
  education(where: EducationSubscriptionWhereInput): EducationSubscriptionPayload
  employee(where: EmployeeSubscriptionWhereInput): EmployeeSubscriptionPayload
  employeeSkill(where: EmployeeSkillSubscriptionWhereInput): EmployeeSkillSubscriptionPayload
  experience(where: ExperienceSubscriptionWhereInput): ExperienceSubscriptionPayload
  keyPair(where: KeyPairSubscriptionWhereInput): KeyPairSubscriptionPayload
  link(where: LinkSubscriptionWhereInput): LinkSubscriptionPayload
  skill(where: SkillSubscriptionWhereInput): SkillSubscriptionPayload
}
`